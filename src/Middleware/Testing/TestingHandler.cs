/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
*/

using Microsoft.Graph;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;

namespace Graph.Community
{
	public class TestingHandler : DelegatingHandler
	{
		internal TestingHandlerOption TestingOption { get; set; }

		// container for the manual map that has been written by the client
		public Dictionary<string, Dictionary<string, int>> manualMap;

		// dummy url that we are using
		public string redirectURL = "https://dummylocation.microsoft.com";

		public TestingHandler()
			: this(null)
		{
		}

		public TestingHandler(TestingHandlerOption testingOption = null)
			: this(testingOption, null)
		{
		}

		public TestingHandler(TestingHandlerOption testingOption, Dictionary<string, Dictionary<string, int>> manualMap = null)
		{
			TestingOption = testingOption ?? new TestingHandlerOption();
			this.manualMap = manualMap;
		}

		protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
		{
			var requestOption = request.GetMiddlewareOption<TestingHandlerOption>() ?? TestingOption;
			var testResponse = CreateResponse(requestOption, request.RequestUri, request.Method);
			return await Task.FromResult(testResponse);
		}

		private HttpResponseMessage CreateResponse(TestingHandlerOption testingHandlerOption, Uri requestUri, HttpMethod requestMethod)
		{
			string requestID = Guid.NewGuid().ToString();
			DateTime requestDate = DateTime.UtcNow;

			HttpStatusCode statusCode = GetRequestStatus(testingHandlerOption, requestUri.ToString(), requestMethod.ToString());

			var response = new HttpResponseMessage(statusCode);

			response.Headers.CacheControl = new CacheControlHeaderValue { Private = true };
			response.Headers.Add("request-id", requestID);
			response.Headers.Add("client-request-id", requestID);
			response.Headers.Add("x-ms-ags-diagnostic", "");
			response.Headers.Date = requestDate;

			if (statusCode == HttpStatusCode.Moved ||   // 301
					statusCode == HttpStatusCode.Found ||   // 302
					statusCode == HttpStatusCode.RedirectMethod || //  303
					statusCode == HttpStatusCode.RedirectKeepVerb ||    // 307
					(int)statusCode == 308)
			{
				// adding location header for only these cases as done for the redirect handler
				response.Headers.Location = new Uri(this.redirectURL);
			}

			if ((int)statusCode == 429)
			{
				// throttling case has to have a timeout scenario
				response.Headers.Add("retry-after", "300");
			}

			// response body gets created as empty for passed cases
			// response body contains error field for failure scenarios
			if ((int)statusCode >= 400)
			{
				var responseContent = testingHandlerOption.ErrorResource ??
					new Error
					{
						Code = statusCode.ToString(),
						Message = "Error generated by Graph.Community.TestingHandler"
					};
				response.Content = new StringContent(JsonConvert.SerializeObject(responseContent));
			}
			else
			{
				response.Content = new StringContent(JsonConvert.SerializeObject(new { }));
			}

			return response;
		}

		private string GetRelativeURL(string pattern, string urlMethod)
		{
			// just helps in getting the relative URL from the complete url, just to match the url as in manual map
			string relativeURL = Regex.Replace(urlMethod, pattern, string.Empty);
			return relativeURL;
		}

		private HttpStatusCode GetRequestStatus(TestingHandlerOption testingHandlerOptions, string requestURL, string requestMethod)
		{
			HttpStatusCode? statusCode = null;

			if (testingHandlerOptions.TestingStrategy == TestingStrategy.Manual)
			{
				if (testingHandlerOptions.StatusCode.HasValue)
				{
					statusCode = testingHandlerOptions.StatusCode.Value;
				}
				else
				{
					// manual mode with no status code
					var relativeUrl = this.GetRelativeURL("http(s)://graph.microsoft.com/[^/]*", requestURL);

					// checking Manual Map for exact match
					if (this.manualMap.TryGetValue(relativeUrl, out Dictionary<string, int> methodMap))
					{
						if (methodMap.TryGetValue(requestMethod, out int mappedResponseCode))
						{
							statusCode = (HttpStatusCode?)mappedResponseCode;
						}
					}
					else
					{
						// checking for regex match if exact match doesn't work
						foreach (var mapEntry in this.manualMap)
						{
							string pattern = mapEntry.Key;
							if (Regex.IsMatch(relativeUrl, pattern))
							{
								statusCode = (HttpStatusCode?)mapEntry.Value[requestMethod];
							}
						}

						// Case of redirection or request url not in map
						if (!statusCode.HasValue)
						{
							/*
							 * not sure what they are trying to accomplish here...
							 * 
							 */
							//if (requestURL == this.redirectURL)
							//{
							//	// we send a 404 after a single redirect if it's done (chain contains redirect Handler)
							//	statusCode = HttpStatusCode.NotFound;
							//	statusMessage = statusCode.Value.ToString();
							//}
						}
					}
				}
			}
			else
			{
				// Handling the case of Random here
				statusCode = (HttpStatusCode?)this.GetRandomStatusCode(requestMethod);
			}

			if (!statusCode.HasValue)
			{
				throw new Exception("API not available in map");
			}

			return statusCode.Value;
		}


		private int GetRandomStatusCode(string requestMethod)
		{
			int[] statusCodeArray = MethodStatusCodes[requestMethod];
			return statusCodeArray[random.Next(0, statusCodeArray.Length)];
		}


		private readonly Dictionary<string, int[]> MethodStatusCodes = new Dictionary<string, int[]>
		{
			{ "GET", new int[] {200, 301, 307, 400, 401, 403, 404, 405, 429, 500, 502, 503, 504 } },
			{ "POST", new int[] {200, 201, 204, 307, 400, 401, 403, 404, 405, 429, 500, 502, 503, 504, 507 } },
			{ "PUT", new int[] {200, 201, 400, 401, 403, 404, 405, 409, 429, 500, 502, 503, 504, 507 } },
			{ "PATCH", new int[] {200, 204, 400, 401, 403, 404, 405, 429, 500, 502, 503, 504 } },
			{ "DELETE", new int[] {200, 204, 400, 401, 403, 404, 405, 429, 500, 502, 503, 504, 507 } }
		};

		private readonly Random random = new Random();
	}
}

